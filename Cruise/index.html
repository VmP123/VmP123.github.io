<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cruise Control Panic</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c2c2c;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
        }
        canvas {
            background-color: #4CAF50;
            border: 5px solid #fff;
            box-shadow: 0 0 25px rgba(0,0,0,0.6);
            /* border-radius: 10px; */
        }

        @media (max-width: 768px) {
            canvas {
                border: none;
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const BASE_WIDTH = 400;
        const BASE_HEIGHT = 600;
        const ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;

        const ROAD_WIDTH_RATIO = 0.6;
        const ROAD_LANE_COUNT = 3;
        const MIN_OBSTACLE_GAP_Y = 100;
        const ROAD_LINE_WIDTH = 5;
        const CAR_WIDTH = 44;
        const CAR_HEIGHT = 74;
        const PLAYER_Y_OFFSET = 120;

        const ROAD_SPEED_0 = 0;
        const ROAD_SPEED_50 = 50 * 5;
        const ROAD_SPEED_100 = 100 * 5;
        const INITIAL_ROAD_SPEED = 10 * 5; 
        const MAX_ROAD_SPEED = 100 * 5;
        const ROAD_SPEED_INCREASE_RATE = 35;
        const MAX_PLAYER_SPEED = 240;
        const PLAYER_ACCELERATION = 3000;
        const OBSTACLE_MIN_SPEED = 50;
				const SPEED_CHANGE_METER_INTERVAL = 1000;

        const PLAYER_CAR_BODY = '#0099ff';
        const PLAYER_CAR_ROOF = '#66ccff';
        const OBSTACLE_COLORS = [
            { body: '#d4ac0d', roof: '#f5cba7' },
            { body: '#5cb85c', roof: '#98d198' },
            { body: '#ff4444', roof: '#ff8888' }
        ];
        const TAIL_LIGHTS_COLOR = '#B71C1C';

        let scaleW, scaleH;
        let ROAD_WIDTH, ROAD_X, LANE_WIDTH;
        let odometer, keys, roadSpeed, player, obstacles, sceneryObjects, lineDashOffset;
        let lastTime = 0;
        let animationFrameId;
        let canSpawn = false;
        let points = 0;
				let currentTraficSign = null;
        let gameState = 'startScreen'; // 'startScreen', 'playing', 'gameOver'
        const coverImg = new Image();
        let isCoverImageLoaded = false;
        let showStartText = false;


        function isMobile() {
            return window.innerWidth <= 768;
        }

        function handleResize() {
            if (isMobile()) {
                // On mobile, try to fill the screen
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                if (windowAspectRatio > ASPECT_RATIO) {
                    // Window is wider than the game, so height is the limiting factor
                    canvas.height = window.innerHeight;
                    canvas.width = canvas.height * ASPECT_RATIO;
                } else {
                    // Window is taller than the game, so width is the limiting factor
                    canvas.width = window.innerWidth;
                    canvas.height = canvas.width / ASPECT_RATIO;
                }
            } else {
                // Desktop scaling
                canvas.height = window.innerHeight * 0.8;
                canvas.width = canvas.height * ASPECT_RATIO;
            }

            scaleH = canvas.height / BASE_HEIGHT;
            scaleW = canvas.width / BASE_WIDTH;

            if (gameState === 'gameOver') {
                drawGameOver();
            } else if (gameState === 'startScreen') {
                drawStartScreen();
            }
        }

        function startGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            gameState = 'playing';
            
            ROAD_WIDTH = BASE_WIDTH * ROAD_WIDTH_RATIO;
            ROAD_X = (BASE_WIDTH - ROAD_WIDTH) / 2;
            LANE_WIDTH = ROAD_WIDTH / ROAD_LANE_COUNT;

            odometer = 0;
            keys = {};
            lineDashOffset = 0;
            roadSpeed = ROAD_SPEED_0;
            points = 0;
						setRoadState('speed_50');

            player = {
                width: CAR_WIDTH, height: CAR_HEIGHT,
                x: ROAD_X + LANE_WIDTH + (LANE_WIDTH / 2) - (CAR_WIDTH / 2),
                y: BASE_HEIGHT - PLAYER_Y_OFFSET,
                speed: 0
            };

            obstacles = [];
            sceneryObjects = [];
            for (let i = 0; i < 10; i++) {
                createSceneryObject(i * (BASE_HEIGHT / 10));
            }

            lastTime = 0;

            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            if ((gameState === 'startScreen' || gameState === 'gameOver') && e.key === 'Enter') {
                startGame();
            } else if (gameState === 'playing') {
                keys[e.key] = true;
            }
        });
        window.addEventListener('keyup', (e) => { 
            if (gameState === 'playing') {
                keys[e.key] = false; 
            }
        });

        window.addEventListener('touchstart', (e) => {
            if (gameState === 'startScreen' || gameState === 'gameOver') {
                startGame();
                return;
            }

            if (gameState === 'playing') {
                e.preventDefault();
                const touchX = e.touches[0].clientX;
                const screenWidth = window.innerWidth;

                if (touchX < screenWidth / 2) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (gameState === 'playing') {
                e.preventDefault();
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        function update(dt) {
            let targetSpeed = 0;
            if (keys['ArrowLeft'] || keys['a']) targetSpeed = -MAX_PLAYER_SPEED;
            else if (keys['ArrowRight'] || keys['d']) targetSpeed = MAX_PLAYER_SPEED;

            if (player.speed < targetSpeed) player.speed = Math.min(player.speed + PLAYER_ACCELERATION * dt, targetSpeed);
            else if (player.speed > targetSpeed) player.speed = Math.max(player.speed - PLAYER_ACCELERATION * dt, targetSpeed);
            player.x += player.speed * dt;
            
            player.x = Math.max(ROAD_X + ROAD_LINE_WIDTH, player.x);
            player.x = Math.min(ROAD_X + ROAD_WIDTH - player.width - ROAD_LINE_WIDTH, player.x);
            
            sceneryObjects.forEach(obj => {
                obj.y += roadSpeed * dt;
                if (obj.y > BASE_HEIGHT + obj.radius) {
                    obj.y = -obj.radius;
                    const roadSideWidth = ROAD_X - 40;
                    obj.x = Math.random() < 0.5 ? Math.random() * roadSideWidth + 20 : ROAD_X + ROAD_WIDTH + Math.random() * roadSideWidth + 20;
                }
            });
            lineDashOffset = (lineDashOffset - roadSpeed * dt) % 60;

            const obstaclesMinY = Math.min(...obstacles.map(obs => obs.y), BASE_HEIGHT);
            const spawnProbability = obstaclesMinY > MIN_OBSTACLE_GAP_Y ? acceleratingProbability(obstaclesMinY - MIN_OBSTACLE_GAP_Y, BASE_HEIGHT, 2) : 0;

            if (Math.random() < spawnProbability) {
                var centerBiasedRandomValue = centerBiasedRandom();
                const lane = Math.floor(centerBiasedRandomValue * ROAD_LANE_COUNT);
                const obstacleInSameLane = obstacles.filter(o => o.lane == lane).sort((a, b) => b.speed - a.speed)?.[0];
                
                const minSpeed = obstacleInSameLane?.speed ?? OBSTACLE_MIN_SPEED;
                const maxSpeed = targetRoadSpeed * 0.6
                const speed = minSpeed + (Math.random() * (maxSpeed - minSpeed))
                
                obstacles.push({
                    x: ROAD_X + (lane * LANE_WIDTH) + (LANE_WIDTH / 2) - (CAR_WIDTH / 2),
                    y: -CAR_HEIGHT, width: CAR_WIDTH, height: CAR_HEIGHT,
                    color: OBSTACLE_COLORS[Math.floor(Math.random() * OBSTACLE_COLORS.length)],
                    speed: speed,
                    lane: lane
                });
            }

            obstacles.forEach(obstacle => {
                obstacle.y += (roadSpeed - obstacle.speed) * dt;

                if (obstacle.y > BASE_HEIGHT - PLAYER_Y_OFFSET + CAR_HEIGHT && !obstacle.scored) {
                    points++;
                    obstacle.scored = true;
                }

                if (player.x < obstacle.x + obstacle.width && player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height && player.y + player.height > obstacle.y) {
                    gameState = 'gameOver';
                }
            });
            obstacles = obstacles.filter(obstacle => obstacle.y < BASE_HEIGHT);

						const nextOdometer = odometer + roadSpeed * dt;

						roundedOdometerAsMeters = Math.floor(pixelsToMeters(odometer)/500);
						roundedNextOdometerAsMeters = Math.floor(pixelsToMeters(nextOdometer)/500);
						
						if (roundedOdometerAsMeters != roundedNextOdometerAsMeters) {
							var result = roundedNextOdometerAsMeters % 3;

							if (result == 0)
								setRoadState('speed_50');
							if (result == 1)
								setRoadState('speed_100');
						}

						odometer = nextOdometer;

            if (roadSpeed < targetRoadSpeed) {
                roadSpeed += ROAD_SPEED_INCREASE_RATE * dt;
                if (roadSpeed > targetRoadSpeed) {
                    roadSpeed = targetRoadSpeed;
                }
            }
            else if (roadSpeed > targetRoadSpeed) {
                roadSpeed -= ROAD_SPEED_INCREASE_RATE * dt;
                if (roadSpeed < targetRoadSpeed) {
                    roadSpeed = targetRoadSpeed;
                }
            }
        }

        function acceleratingProbability(min, max, alpha = 2) {
            const t = Math.min(min, max);
            return Math.pow(t / max, alpha);
        }

        function centerBiasedRandom() {
            let randomValue = Math.random() < 0.3 ? (Math.random() + Math.random()) / 2 : Math.random();
            return randomValue;
        }

        function createSceneryObject(yPos = -30) {
            const roadSideWidth = ROAD_X - 40;
            const xPos = Math.random() < 0.5 ? Math.random() * roadSideWidth + 20 : ROAD_X + ROAD_WIDTH + Math.random() * roadSideWidth + 20;
            sceneryObjects.push({
                x: xPos, y: yPos, radius: Math.random() * 15 + 10, trunkWidth: 8
            });
        }
        
				function pixelsToMeters(odometer) {
					return odometer / 18;
				}

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawGround();
            drawRoad();
            drawSceneryObjects();
            drawTraficSigns();
            drawCars();
            //drawTexts();
						drawDigitalDashboard();
        }

        function drawGround() {
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawRoad() {
            ctx.fillStyle = '#666';
            ctx.fillRect(ROAD_X * scaleW, 0, ROAD_WIDTH * scaleW, canvas.height);
            ctx.strokeStyle = 'white';
            ctx.setLineDash([25 * scaleH, 35 * scaleH]);
            ctx.lineDashOffset = lineDashOffset * scaleH;
            for (let i = 1; i < ROAD_LANE_COUNT; i++) {
                const x = (ROAD_X + i * LANE_WIDTH) * scaleW;
                ctx.beginPath();
                ctx.lineWidth = ROAD_LINE_WIDTH * scaleW;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            ctx.fillStyle = 'white';
            ctx.fillRect(ROAD_X * scaleW, 0, ROAD_LINE_WIDTH * scaleW, canvas.height);
            ctx.fillRect((ROAD_X + ROAD_WIDTH - ROAD_LINE_WIDTH) * scaleW, 0, ROAD_LINE_WIDTH * scaleW, canvas.height);
        }

        function drawSceneryObjects() {
            sceneryObjects.sort((a,b) => a.y - b.y).forEach(obj => drawSceneryObject(obj.x, obj.y, obj.radius, obj.trunkWidth));
        }

        function drawSceneryObject(x, y, radius, trunkWidth) {
            const sx = x * scaleW, sy = y * scaleH, sRadius = radius * scaleH, sTrunkWidth = trunkWidth * scaleW;
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(sx - sTrunkWidth / 2, sy, sTrunkWidth, sRadius * 2);
            ctx.fillStyle = '#388E3C';
            ctx.beginPath();
            ctx.arc(sx, sy, sRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTraficSigns() {
						if (currentTraficSign) {
							drawTraficSign(currentTraficSign);
						}
        }

        function drawTraficSign(type) {
            if (type === 'speed_50') {
                drawSpeedSign('speed_50');
            } else if (type === 'speed_100') {
                drawSpeedSign('speed_100');
            } else {
                console.warn(`Tuntematon liikennemerkki: ${type}`);
            }
        }

        function drawSpeedSign(type) {
            var centerX = ROAD_X + ROAD_WIDTH + (ROAD_X * 0.5);
            var centerY = 560;

            const colorYellow = "#ffcd00";
            const colorRed = "#e5002b";

            ctx.fillStyle = colorYellow;
            ctx.beginPath();
            ctx.arc(centerX * scaleW, centerY * scaleH, 30 * scaleW, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = colorRed;
            ctx.beginPath();
            ctx.arc(centerX * scaleW, centerY * scaleH, 28 * scaleW, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = colorYellow;
            ctx.beginPath();
            ctx.arc(centerX * scaleW, centerY * scaleH, 21 * scaleW, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = '#202020';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (type == 'speed_50') {
                ctx.font = `bold ${26 * scaleH}px Segoe UI`;
                ctx.fillText(`50`, centerX * scaleW, (centerY + 2) * scaleH);
            }
            else if (type == 'speed_100') {
                ctx.font = `bold ${25 * scaleH}px Segoe UI`;
                ctx.fillText(`1`, (centerX - 14) * scaleW, (centerY + 2) * scaleH);
                ctx.fillText(`0`, (centerX - 3) * scaleW, (centerY + 2) * scaleH);
                ctx.fillText(`0`, (centerX + 11) * scaleW, (centerY + 2) * scaleH);
            }
        }

        function drawCars() {
            obstacles.forEach(obs => drawCar(obs.x, obs.y, obs.width, obs.height, obs.color.body, obs.color.roof));
            drawCar(player.x, player.y, player.width, player.height, PLAYER_CAR_BODY, PLAYER_CAR_ROOF);
        }

        function drawCar(x, y, width, height, bodyColor, roofColor) {
            const sx = x * scaleW, sy = y * scaleH, sw = width * scaleW, sh = height * scaleH;
            ctx.fillStyle = bodyColor;
            ctx.fillRect(sx, sy, sw, sh);
            ctx.fillStyle = roofColor;
            ctx.fillRect(sx + sw * 0.15, sy + sh * 0.30, sw * 0.7, sh * 0.45);
            ctx.fillStyle = TAIL_LIGHTS_COLOR;
            ctx.fillRect(sx + 4 * scaleW, sy + sh - 12 * scaleH, 8 * scaleW, 6 * scaleH);
            ctx.fillRect(sx + sw - 12 * scaleW, sy + sh - 12 * scaleH, 8 * scaleW, 6 * scaleH);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = `bold ${48 * scaleH}px Segoe UI`;
            ctx.fillText('PELI OHI', canvas.width / 2, canvas.height / 2 - 40 * scaleH);
            ctx.font = `${24 * scaleH}px Segoe UI`;
            ctx.fillText(`Lopulliset pisteet: ${points}`, canvas.width / 2, canvas.height / 2 + 10 * scaleH);
            ctx.font = `${20 * scaleH}px Segoe UI`;
            const actionText = isMobile() ? 'Kosketa näyttöä' : 'Paina Enter';
            ctx.fillText(`${actionText} aloittaaksesi uudelleen`, canvas.width / 2, canvas.height / 2 + 60 * scaleH);
        }

				function drawTexts() {
					ctx.font = `bold ${24 * scaleH}px Segoe UI`;
					ctx.fillStyle = 'white';
					ctx.textAlign = 'left';
            
					ctx.fillText(points, 5 * scaleW, 35 * scaleH);
					ctx.fillText(roadSpeed.toFixed(0), 5 * scaleW, 55 * scaleH);
					ctx.fillText(`${(Math.floor(pixelsToMeters(odometer)))} m`, 5 * scaleW, 75 * scaleH);
				}

        function drawDigitalDashboard() {
					const margin = 10 * scaleW;

					const width = ROAD_X * scaleW - (2 * margin);
					const height = width * 0.85
					const x = margin;
					const y = canvas.height - height - margin;

					ctx.save();

					ctx.fillStyle = '#111';
					ctx.strokeStyle = '#333';
					ctx.lineWidth = 1.5 * scaleW;

					ctx.beginPath();
					ctx.roundRect(x, y, width, height, 6 * scaleW);
					ctx.fill();
					ctx.stroke();

					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					const textColor = '#f0f0f0';
					
					const fontSize = height * 0.4;

					const pointsY = y + height * 0.36;
					const pointsText = points.toString().padStart(4, '0').replaceAll('0', 'O');
					ctx.font = `bold ${fontSize}px monospace`;
					ctx.fillStyle = textColor;
					ctx.fillText(pointsText, x + width / 2, pointsY);

					const odoY = y + height * 0.7;
					const km = (Math.floor(pixelsToMeters(odometer) / 100) / 10).toFixed(1)
					const odometerText = km.padStart(4, '0').replaceAll('0', 'O');
					ctx.font = `bold ${fontSize}px monospace`;
					ctx.fillStyle = textColor;
					ctx.fillText(odometerText, x + width / 2, odoY);

					ctx.restore();
        }

        function drawStartScreen() {
            if (isCoverImageLoaded) {
                ctx.drawImage(coverImg, 0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (showStartText) {
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.font = `bold ${16 * scaleH}px Segoe UI`;
                    const actionText = isMobile() ? 'Kosketa näyttöä' : 'Paina Enter';
                    ctx.fillText(`${actionText} aloittaaksesi`, canvas.width / 2, canvas.height - 60 * scaleH);
                }
            } else {
                ctx.fillStyle = '#2c2c2c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `bold ${32 * scaleH}px Segoe UI`;
                ctx.fillText('Ladataan...', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameLoop(currentTime) {
            if (gameState === 'gameOver') {
                drawGameOver();
                return;
            }
            
            if (gameState === 'startScreen') {
                drawStartScreen();
            } else if (gameState === 'playing') {
                if (lastTime === 0) lastTime = currentTime;
                const dt = (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                update(dt);
                draw();
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

				function setRoadState(state) {
					if (state == 'speed_50') {
						targetRoadSpeed = ROAD_SPEED_50;
						currentTraficSign = 'speed_50';
					}
					else if (state == 'speed_100') {
						targetRoadSpeed = ROAD_SPEED_100;
						currentTraficSign = 'speed_100';
					}
				}

        window.addEventListener('resize', handleResize);

        handleResize();
        
        coverImg.onload = () => {
            isCoverImageLoaded = true;
            setTimeout(() => {
                showStartText = true;
            }, 5000);
        };
        coverImg.src = 'cover.png';

        gameLoop(0);

    </script>
</body>
</html>